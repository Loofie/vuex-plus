import { getTagName, getInstances } from '../common/helpers.js';

/**
 * The api for all stores
 * The api is autogenerated once the module importer has been set
 * ```
 *   api.someStore.get.something => vuex magic string for vuex getter
 * ```
 */
export const api = {};
/**
 * Set api
 * @param {Object} newApi The new api
 */
export const setApi = (newApi) => {
  Object.keys(newApi).forEach((key) => {
    api[key] = newApi[key];
  });
};

/**
 * Match array of results strings and return the ones matching parent instances
 */
/**
 * Match array of results strings and return the ones matching parent instances
 * @param  {array} allResults    All unmatched results
 * @param  {array} pathInstances All the instances found in the instance branch
 * @return {array}               An array with results matched the the instance branch
 */
export const matchToInstances = (allResults, pathInstances) => {
  const results = [];
  allResults
    .forEach((path) => {
      let workingPath = path;
      let pathMatchesInstances;

      if (pathInstances.length === 0) {
        pathMatchesInstances = path.indexOf('$') === -1;
      } else {
        pathMatchesInstances = pathInstances.reduce((acc, curr) => {
          const $idx = workingPath.indexOf('$');
          const result = workingPath.indexOf(curr + '/') === $idx;
          workingPath = workingPath.slice($idx + curr.length + 1);
          return acc && result;
        }, true);
      }

      if (pathMatchesInstances) {
        results.push(path);
      }
    });

  return results;
};

/**
 * Input subpath and figure out full path
 * @param  {string} subpath The subpath to start from
 * @param  {Object} self    Vue component `.this`
 * @return {string}         Full path
 */
export const getFullPath = (subpath, self) => {
  if (!subpath) {
    console.error('[Vuex+ warn]: Cant calculate path', subpath, 'for', self);
    return undefined;
  }

  const pathInstances = getInstances(subpath, self);
  const { storeInstanceName } = self['$vuex+'];
  const getterKey = subpath.split('/')[0];
  if (getterKey === self['$vuex+'].storeInstanceName) {
    return subpath;
  }
  const key = subpath.slice(getterKey.length + 1);
  const suffix = self.instance ? '\\$' + self.instance : '';

  const localApi = api[storeInstanceName];
  const apiString = JSON.stringify(localApi, undefined, 2);
  const regexp = new RegExp('\\"?[\\w\\/\\$]*?[\\/|\\"]' +
                            getterKey + suffix + '\\/' +
                            key.replace(/\$/g, '\\$') + '\\"', 'g');

  const allResults = apiString.match(regexp);
  if (!allResults) {
    const instance = getterKey.indexOf('$') < 0 ? getterKey + '$' + self.instance : getterKey;
    console.error('[Vuex+ warn]: Cant find substore instance "' + instance + '" in "' + getTagName(self) + '"' +
                  ', when looking for', getterKey + '/' + key + '. Api is:', api, undefined, 2);
    return undefined;
  }

  const relevantResults = allResults
                            .map(r => r.slice(1, -1))
                            .filter(r => r.slice(0, getterKey.length) === getterKey ||
                                         r.indexOf('/' + getterKey + '/' + key));

  const results = matchToInstances(relevantResults, pathInstances);

  if (!results) {
    console.warn('[Vuex+] Could not determine path to', subpath, ', matching with instances:', pathInstances,
      'in', localApi, 'for tag', getTagName(self) + '.\nResults were:', results, '\nRecommended action is to add explicit instances.');
  }

  return results[0];
};

/**
 * Set instance to all toplevel stores in `storeApi` paths
 * @param  {Object} storeApi      The store api
 * @param  {string} baseStoreName Base store name
 * @param  {string} newStoreName  New store name
 * @return {Object}               Store api remapped with toplevel instance names
 */
export function remapBaseStore(storeApi, baseStoreName, newStoreName) {
  newStoreName = newStoreName || baseStoreName;
  const result = {};
  Object.keys(storeApi).forEach((type) => {
    if (type === 'get' || type === 'act' || type === 'mutate') {
      result[type] = {};
      Object.keys(storeApi[type]).forEach((pathName) => {
        result[type][pathName] = storeApi[type][pathName].replace(baseStoreName, newStoreName);
      });
    } else {
      result[type] = remapBaseStore(storeApi[type], baseStoreName, newStoreName);
    }
  });

  return result;
}
