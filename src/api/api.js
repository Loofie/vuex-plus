/**
 * The api for all stores
 * The api is autogenerated once the module importer has been set
 * ```
 *   api.aStore.get.something => vuex magic string for vuex getter
 * ```
 */
export const api = {};
export const setApi = (newApi) => {
  Object.keys(newApi).forEach((key) => {
    api[key] = newApi[key];
  });
};

/**
 * Match array of results strings and return the ones matching parent instances
 */
export const matchToInstances = (allResults, parentInstances) => {
  const results = [];
  allResults
    .forEach((path) => {
      let workingPath = path;
      let pathMatchesInstances;

      if (parentInstances.length === 0) {
        pathMatchesInstances = path.indexOf('$') === -1;
      } else {
        pathMatchesInstances = parentInstances.reduce((acc, curr) => {
          const $idx = workingPath.indexOf('$');
          const result = workingPath.indexOf(curr + '/') === $idx;
          workingPath = workingPath.slice($idx + curr.length + 1);
          return acc && result;
        }, true);
      }

      if (pathMatchesInstances) {
        results.push(path);
      }
    });

  return results;
};

/**
 * Input subpath and figure out full path
 * config: {
 *  subpath: 'some/path',
 *  instance: this.instance,  // 'instanceName',
 *  parentInstances: ['$a', '$b'],
 *  vuexPlus: this['$vuex+'], // { baseStoreName: 'top', storeInstanceName: 'top' },
 *  container: 'tag name for better error output',
 * }
 */
export const getFullPath = (config) => {
  const suffix = config.instance ? '\\$' + config.instance : '';
  if (!config.subpath) {
    console.error('[Vuex+ warn]: Cant calculate path', config);
    return undefined;
  }
  const getterKey = config.subpath.match(/\w*/)[0];
  const key = config.subpath.slice(getterKey.length + 1);
  const localApi = api[config.vuexPlus.storeInstanceName];
  const apiString = JSON.stringify(localApi, undefined, 2);
  const regexp = new RegExp('\\"?[\\w\\/\\$]*?[\\/|\\"]' + getterKey + suffix + '\\/' + key.replace(/\$/g, '\\$') + '\\"', 'g');

  const allResults = apiString.match(regexp);

  if (!allResults) {
    const instance = config.subpath.split('/')[0] + '$' + config.instance;
    console.error('[Vuex+ warn]: Cant find substore instance "' + instance + '" in "' + config.container + '"' +
                  ', when looking for', getterKey + '/' + key + '. Api is:', api, undefined, 2);
    return undefined;
  }

  const relevantResults = allResults
                            .map(r => r.slice(1, -1))
                            .filter(r => r.slice(0, getterKey.length) === getterKey ||
                                         r.indexOf('/' + getterKey + '/' + key));

  let results = matchToInstances(relevantResults, config.parentInstances); // eslint-disable-line

  if (!results) {
    console.warn('[Vuex+] Could not determine path to', config.subpath, ', matching with instances:', config.parentInstances,
      'in', localApi, 'for tag', config.container + '.\nResults were:', results, '\nRecommended action is to add explicit instances.');
  }

  return results[0];
};

/**
 * Set instance to all toplevel stores in `storeApi` paths
 */
export function remapBaseStore(storeApi, baseStoreName, newStoreName) {
  newStoreName = newStoreName || baseStoreName;
  const result = {};
  Object.keys(storeApi).forEach((type) => {
    if (type === 'get' || type === 'act' || type === 'mutate') {
      result[type] = {};
      Object.keys(storeApi[type]).forEach((pathName) => {
        result[type][pathName] = storeApi[type][pathName].replace(baseStoreName, newStoreName);
      });
    } else {
      result[type] = remapBaseStore(storeApi[type], baseStoreName, newStoreName);
    }
  });

  return result;
}
