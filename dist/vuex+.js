'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var contextHmr = _interopDefault(require('webpack-context-vuex-hmr'));
var clone = _interopDefault(require('clone'));

var getStoreInstanceName = function (storeName, instance) {
  if (instance) {
    return storeName + '$' + instance;
  }
  return storeName;
};


var toCamelCase = function (str) {
  if (!str) {
    return '';
  }
  return str.replace(/(-|_)([\w])/g, function (s) { return s[1].toUpperCase(); });
};


var getLocalPath = function (path, state) {
  var storeName = state['vuex+'].storeName;
  var instance = state['vuex+'].instance;
  return path.replace(storeName, getStoreInstanceName(storeName, instance));
};


var getTagName = function (self) {
  var tag = 'unknown-tag';
  if (self.$parent) {
    var vnode = self.$parent.$vnode || self.$parent._vnode; // eslint-disable-line

    if (vnode && vnode.componentOptions && vnode.componentOptions.tag) {
      tag = vnode.componentOptions.tag;
    }
  }
  return '<' + tag + '>';
};


var getInstances = function (subpath, self) {
  var path = self.instance ? '/$' + self.instance : '';
  var parent = self;

  while (parent.$parent) {
    parent = parent.$parent;
    var suffix = parent.instance ? '$' + parent.instance + '/' : '';
    if (suffix) { path = suffix + path; }
  }

  var instances = path === '' ? [] : path.split('/').filter(function (i) { return i.length; });

  if (subpath) {
    var subInstances = subpath.match(/\$\w+/g);
    if (subInstances) {
      subInstances.forEach(function (instance) {
        instances.push(instance);
      });
    }
  }

  return instances;
};

/**
 * The api for all stores
 * The api is autogenerated once the module importer has been set
 * ```
 *   api.aStore.get.something => vuex magic string for vuex getter
 * ```
 */
var api = {};


/**
 * Match array of results strings and return the ones matching parent instances
 */
var matchToInstances = function (allResults, pathInstances) {
  var results = [];
  allResults
    .forEach(function (path) {
      var workingPath = path;
      var pathMatchesInstances;

      if (pathInstances.length === 0) {
        pathMatchesInstances = path.indexOf('$') === -1;
      } else {
        pathMatchesInstances = pathInstances.reduce(function (acc, curr) {
          var $idx = workingPath.indexOf('$');
          var result = workingPath.indexOf(curr + '/') === $idx;
          workingPath = workingPath.slice($idx + curr.length + 1);
          return acc && result;
        }, true);
      }

      if (pathMatchesInstances) {
        results.push(path);
      }
    });

  return results;
};

/**
 * Input subpath and figure out full path
 * @param (string) subpath
 * @param (Object) self - vuex module `this`
 * @returns (string) full path
 */
var getFullPath = function (subpath, self) {
  if (!subpath) {
    console.error('[Vuex+ warn]: Cant calculate path', subpath, 'for', self);
    return undefined;
  }

  var pathInstances = getInstances(subpath, self);
  var ref = self['$vuex+'];
  var storeInstanceName = ref.storeInstanceName;
  var getterKey = subpath.split('/')[0];
  if (getterKey === self['$vuex+'].storeInstanceName) {
    return subpath;
  }
  var key = subpath.slice(getterKey.length + 1);
  var suffix = self.instance ? '\\$' + self.instance : '';

  var localApi = api[storeInstanceName];
  var apiString = JSON.stringify(localApi, undefined, 2);
  var regexp = new RegExp('\\"?[\\w\\/\\$]*?[\\/|\\"]' +
                            getterKey + suffix + '\\/' +
                            key.replace(/\$/g, '\\$') + '\\"', 'g');

  var allResults = apiString.match(regexp);
  if (!allResults) {
    var instance = getterKey.indexOf('$') < 0 ? getterKey + '$' + self.instance : getterKey;
    console.error('[Vuex+ warn]: Cant find substore instance "' + instance + '" in "' + getTagName(self) + '"' +
                  ', when looking for', getterKey + '/' + key + '. Api is:', api, undefined, 2);
    return undefined;
  }

  var relevantResults = allResults
                            .map(function (r) { return r.slice(1, -1); })
                            .filter(function (r) { return r.slice(0, getterKey.length) === getterKey ||
                                         r.indexOf('/' + getterKey + '/' + key); });

  var results = matchToInstances(relevantResults, pathInstances);

  if (!results) {
    console.warn('[Vuex+] Could not determine path to', subpath, ', matching with instances:', pathInstances,
      'in', localApi, 'for tag', getTagName(self) + '.\nResults were:', results, '\nRecommended action is to add explicit instances.');
  }

  return results[0];
};

/**
 * Set instance to all toplevel stores in `storeApi` paths
 */
function remapBaseStore(storeApi, baseStoreName, newStoreName) {
  newStoreName = newStoreName || baseStoreName;
  var result = {};
  Object.keys(storeApi).forEach(function (type) {
    if (type === 'get' || type === 'act' || type === 'mutate') {
      result[type] = {};
      Object.keys(storeApi[type]).forEach(function (pathName) {
        result[type][pathName] = storeApi[type][pathName].replace(baseStoreName, newStoreName);
      });
    } else {
      result[type] = remapBaseStore(storeApi[type], baseStoreName, newStoreName);
    }
  });

  return result;
}

var vuexInstance = {};

var handlers = [];




var registerForHMR = function (newStore, baseStoreName, storeInstanceName) {
  handlers.push({
    storeName: baseStoreName + '-store',
    storeInstanceName: storeInstanceName,
    newStore: newStore,
  });
};

var unregisterForHMR = function (newStore) {
  handlers = handlers.filter(function (h) { return h.newStore !== newStore; });
};

var hmrHandler = function (updatedModules) {
  var modules = {};
  Object.keys(updatedModules).forEach(function (key) {
    var storeName = toCamelCase(key.replace('-store', '')) + '-store';
    handlers
      .filter(function (handler) { return handler.storeName === storeName; })
      .forEach(function (handler) {
        modules[handler.storeInstanceName] = handler.newStore(updatedModules[key]);
      });

    Object.keys(modules).forEach(function (m) {
      api[m] = remapBaseStore(modules[m].$api, modules[m].name, m);
    });
    vuexInstance.store.hotUpdate({ modules: modules });
  });
};

/**
 * Create new namespaced store instance
 * @param {string} storeInstanceName - The full instance name
 * @param {string} instance - Instance name, same as in `instance="my-counter"`
 * @param {string} baseStoreName - The base store name, same as in `store({ name })`
 * @param {Object} store - The base store name, same as in `store({ name })`
 * @returns {Object} Vuex module store with submodules
 */
function newStore(storeInstanceName, instance, baseStoreName, store) {
  var resultingStore = {
    namespaced: true,
  };

  Object.assign(resultingStore, store);
  resultingStore.state = {};
  if (store.state) {
    resultingStore.state = clone(store.state, false);
  }
  resultingStore.state['vuex+'] = {};
  if (instance) {
    resultingStore.state['vuex+'].instance = instance;
  }
  resultingStore.state['vuex+'].storeName = baseStoreName;
  ['actions', 'getters', 'mutations'].forEach(function (type) {
    if (store[type]) {
      resultingStore[type] = {};
      Object.keys(store[type]).forEach(function (name) {
        var newName = name.replace(baseStoreName, storeInstanceName);
        resultingStore[type][newName] = store[type][name];
      });
    }
  });
  if (resultingStore.modules) {
    resultingStore.modules = {};
    Object.keys(store.modules).forEach(function (subInstanceName) {
      resultingStore.modules[subInstanceName] = newStore(storeInstanceName, instance, baseStoreName, store.modules[subInstanceName]); // eslint-disable-line
    });
  }

  return resultingStore;
}

var importer;

function setup(newImporter) {
  importer = newImporter;
}

/**
 * Add a new store instance
 * The Vue component gets two props:
 * - instance {string}: Contains the instance name
 * - preserve {boolean}: If true, the store wont be discarded when the final instance is destroyed
 * @param {string} baseStoreName - The base store name, same as the store filename
 * @returns {mixin, api} api for the loaded module and a mixin
 */
function add(baseStoreName) {
  var loadedModule = importer.getModules()[baseStoreName];
  var counter = {};
  function HmrHandler(instanceName, getNewInstanceStore) {
    return function (newLoadedModule) { return getNewInstanceStore(newLoadedModule); };
  }

  return {
    api: loadedModule.api,
    mixin: {
      props: ['instance', 'preserve'],
      created: function created() {
        var this$1 = this;

        baseStoreName = toCamelCase(baseStoreName.replace(/-store$/, ''));
        this['$vuex+'] = {
          baseStoreName: baseStoreName,
          storeInstanceName: getStoreInstanceName(baseStoreName, this.instance),
        };
        counter[this['$vuex+'].storeInstanceName] = counter[this['$vuex+'].storeInstanceName] || 0;
        counter[this['$vuex+'].storeInstanceName]++;

        var getNewInstanceStore = function (newLoadedModule) { return newStore(this$1['$vuex+'].storeInstanceName, this$1.instance,
                                                                baseStoreName, newLoadedModule); };

        var store = getNewInstanceStore(loadedModule);
        if (!this.$store._modules.root._children[this['$vuex+'].storeInstanceName]) { // eslint-disable-line
          this.$store.registerModule(this['$vuex+'].storeInstanceName, store);
          var remappedApi = remapBaseStore(store.$api, this['$vuex+'].baseStoreName, this['$vuex+'].storeInstanceName);
          api[this['$vuex+'].baseStoreName] = store.$api;
          api[this['$vuex+'].storeInstanceName] = remappedApi;

          if (module.hot) {
            this.$hmrHandler = new HmrHandler(this['$vuex+'].storeInstanceName, getNewInstanceStore);
            registerForHMR(this.$hmrHandler, baseStoreName, this['$vuex+'].storeInstanceName);
          }
        }
      },

      destroyed: function destroyed() {
        counter[this['$vuex+'].storeInstanceName]--;

        if (!this.preserve && counter[this['$vuex+'].storeInstanceName] === 0) {
          this.$store.unregisterModule(this['$vuex+'].storeInstanceName);

          if (module.hot) {
            unregisterForHMR(this.$hmrHandler);
          }
        }
      },
    },
  };
}

function setupVuexPlus($store) {
  vuexInstance.store = $store;
  var importer = contextHmr.getNewInstance();
  setup(importer);
  importer.getModules();
  importer.setupHMR(hmrHandler);
}

var _map = {
  /**
   * Map local paths `require('./example-substore.js').api.get.value`
   * to the corresponding vuex getter.
   * @param {Object} map - Object of all computed properties to be mapped to getters
   * @returns {Object} - Object containing the mapped getters
   */
  getters: function getters(map) {
    var result = {};
    Object.keys(map).forEach(function (key) {
      result[key] = function get() {
        var path = getFullPath(map[key], this);
        return this.$store.getters[path];
      };
    });
    return result;
  },

  /**
   * Map local paths `require('./example-substore.js').api.act.value`
   * to the corresponding vuex getter.
   * @param {Object} map - Object of all method properties to be mapped to actions
   * @returns {Object} - Object containing the mapped actions
   */
  actions: function actions(map) {
    var result = {};
    Object.keys(map).forEach(function (key) {
      result[key] = function dispatch(payload) {
        var path = getFullPath(map[key], this);
        return this.$store.dispatch(path, payload);
      };
    });
    return result;
  },
};

var _global = {
  get api() {
    return clone(api);
  },

  /**
   * Method that returns a getter.
   * Only set `state` when getting from same instance
   * @param {string} path - Path as as string, usually from api. Eg. `api.example.get.something`
   * @param {Object} state - Optional local vuex state. Set it when searching in same instance.
   * @returns {any} - Value from Vuex getter
   */
  get: function get(ref) {
    var path = ref.path;
    var state = ref.state;

    if (state) {
      var localPath = getLocalPath(path, state);
      return vuexInstance.store.getters[localPath];
    }

    return vuexInstance.store.getters[path];
  },

  /**
   * Method that dispatches an action.
   * Only set `state` when dispatching in same instance
   * @param {string} path - Path as as string, usually from api. Eg. `api.example.get.something`
   * @param {any} data - Optional data to pass along with action.
   * @param {Object} state - Optional local vuex state. Set it when searching in same instance.
   * @returns {any} - Value from Vuex action
   */
  dispatch: function dispatch(ref) {
    var path = ref.path;
    var data = ref.data;
    var state = ref.state;

    if (state) {
      var localPath = getLocalPath(path, state);
      return vuexInstance.store.dispatch(localPath, data);
    }

    return vuexInstance.store.dispatch(path, data);
  },

  /**
   * Method that commits a mutation.
   * Only set `state` when commiting in same instance
   * @param {string} path - Path as as string, usually from api. Eg. `api.example.get.something`
   * @param {any} data - Optional data to pass along with mutation.
   * @param {Object} state - Optional local vuex state. Set it when searching in same instance.
   * @returns {any} - Value from Vuex mutation
   */
  commit: function commit(ref) {
    var path = ref.path;
    var data = ref.data;
    var state = ref.state;

    if (state) {
      var localPath = getLocalPath(path, state);
      return vuexInstance.store.commit(localPath, data);
    }

    return vuexInstance.store.commit(path, data);
  },
};

/**
 * Private method that modifies magics strings to contain their parents
 * @param {Object} api - object tree with magic strings
 * @param {string} parentName - parentName
 * @returns {Object} all tree nodes have been padded with parentName '/'
 */
function addParentToPath(subapi, parentName) {
  var result = {};
  Object.keys(subapi).forEach(function (type) {
    if (type === 'get' || type === 'act' || type === 'mutate') {
      result[type] = {};
      Object.keys(subapi[type]).forEach(function (pathName) {
        var path = subapi[type][pathName];
        result[type][pathName] = parentName + '/' + path;
      });
    } else {
      result[type] = addParentToPath(subapi[type], parentName);
    }
  });

  return result;
}

/**
 * Modify Vuex Module to contain an api with magic strings
 * Requirement: store.name has to be available
 * @param {Object} store - Vuex module store
 * @returns {Object} Store with added `api` parameter
 */
var _store = function (store) {
  store.api = {};
  store.namespaced = true;

  var camelCasedName = toCamelCase(store.name);

  // Clone getters
  if (store.getters) {
    store.api.get = {};
    Object.keys(store.getters).forEach(function (name) {
      store.api.get[name] = camelCasedName + '/' + name;
    });
  }

  // Clone actions
  if (store.actions) {
    store.api.act = {};
    Object.keys(store.actions).forEach(function (name) {
      store.api.act[name] = camelCasedName + '/' + name;
    });
  }

  // Clone mutations
  if (store.mutations) {
    store.api.mutate = {};
    Object.keys(store.mutations).forEach(function (name) {
      store.api.mutate[name] = camelCasedName + '/' + name;
    });
  }

  // Clone modules
  if (store.modules) {
    Object.keys(store.modules).forEach(function (name) {
      store.api[name] = addParentToPath(store.modules[name].api, camelCasedName);
    });
  }

  store.$api = clone(store.api, false);

  return store;
};

var _newInstance = function (substore, instance) {
  var result = clone(substore);
  result.api = remapBaseStore(result.api, result.name, result.name + '$' + instance);
  return result;
};

var _vuePluginInstall = {
  install: function install(Vue) {
    Vue.mixin({
      props: ['instance'],
      created: function created() {
        var this$1 = this;

        var findModuleName = function (parent) {
          if (!this$1['$vuex+'] && parent.$parent) {
            if (!parent.$parent['$vuex+']) {
              findModuleName(parent.$parent);
            } else {
              this$1['$vuex+'] = {
                baseStoreName: parent.$parent['$vuex+'].baseStoreName,
                storeInstanceName: parent.$parent['$vuex+'].storeInstanceName,
              };
            }
          }
        };

        findModuleName(this);
      },
    });
  },
};

var map = _map;
var store = _store;
var global = _global;
var addStore = add;
var hmrCallback = hmrHandler;
var newInstance = _newInstance;

var vuex_ = {
  vuePlugin: _vuePluginInstall,
  vuexPlugin: setupVuexPlus,
};

exports.map = map;
exports.store = store;
exports.global = global;
exports.addStore = addStore;
exports.hmrCallback = hmrCallback;
exports.newInstance = newInstance;
exports['default'] = vuex_;
